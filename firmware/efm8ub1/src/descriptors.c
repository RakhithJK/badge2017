/*******************************************************************************
 * @file descriptors.c
 * @brief USB descriptors.
 *******************************************************************************/

//=============================================================================
// src/descriptors.c: generated by Hardware Configurator
//
// This file is only generated if it does not exist. Modifications in this file
// will persist even if Configurator generates code. To refresh this file,
// you must first delete it and then regenerate code.
//=============================================================================
//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <si_toolchain.h>
#include <endian.h>
#include <stdlib.h>
#include <string.h>
#include <efm8_usb.h>
#include "descriptors.h"

#ifdef __cplusplus
extern "C" {
#endif

// HID Report Descriptor for Interface 2
SI_SEGMENT_VARIABLE(ReportDescriptor2[],
		const uint8_t,
		SI_SEG_CODE) =
{
		0x06, 0xd0, 0xf1,// USAGE_PAGE (FIDO Alliance)
		0x09, 0x01,// USAGE (Keyboard)
		0xa1, 0x01,// COLLECTION (Application)

		0x85, 0x01,                   //   REPORT_ID (1)
	    0x09, 0x20,                   //   USAGE (Input Report Data)
	    0x15, 0x00,                   //   LOGICAL_MINIMUM (0)
	    0x26, 0xff, 0x00,             //   LOGICAL_MAXIMUM (255)
	    0x75, 0x08,                   //   REPORT_SIZE (8)
	    0x95, U2F_PACKET_SIZE,        //   REPORT_COUNT (63)
	    0x81, 0x02,                   //   INPUT (Data,Var,Abs)
	    0x09, 0x21,                   //   USAGE(Output Report Data)
	    0x15, 0x00,                   //   LOGICAL_MINIMUM (0)
	    0x26, 0xff, 0x00,             //   LOGICAL_MAXIMUM (255)
	    0x75, 0x08,                   //   REPORT_SIZE (8)
	    0x95, U2F_PACKET_SIZE,        //   REPORT_COUNT (63)
	    0x91, 0x02,                   //   OUTPUT (Data,Var,Abs)

		0xc0,// END_COLLECTION

		//  TODO: Use Power Device usage instead?
		0x05, 0x01,// USAGE_PAGE (Generic Desktop)
		0x09, 0x00,// USAGE (Undefined)
		0xa1, 0x01,// COLLECTION (Application)

		0x85, 0x02,                   //   REPORT_ID (2)
		0x09, 0x37,                   //   USAGE (Dial)
		0x15, 0xff,                   //   LOGICAL_MINIMUM (-1)
		0x25, 0x01,                   //   LOGICAL_MAXIMUM (1)
		0x75, 0x02,                   //   REPORT_SIZE (2)
		0x95, 0x01,                   //   REPORT_COUNT (1)
		0x81, 0x06,                   //   INPUT (Data,Var,Rel)
		0x05, 0x09,                   //   USAGE_PAGE (Button)
		0x09, 0x21,                   //   USAGE (Button)
		0x15, 0x00,                   //   LOGICAL_MINIMUM (0)
		0x25, 0x01,                   //   LOGICAL_MAXIMUM (1)
		0x75, 0x01,                   //   REPORT_SIZE (1)
		0x95, 0x01,                   //   REPORT_COUNT (1)
		0x81, 0x02,                   //   INPUT (Data,Var,Abs)
		0x05, 0x01,                   //   USAGE_PAGE (Generic Desktop)
		0x09, 0x00,                   //   USAGE (Undefined)
		0x75, 0x01,                   //   REPORT_SIZE (1)
		0x95, 0x05,                   //   REPORT_COUNT (5)
		0x81, 0x02,                   //   INPUT (Data,Var,Abs)
		0x09, 0x00,                   //   USAGE (Undefined)
		0x75, 0x01,                   //   REPORT_SIZE (1)
		0x95, 0x08,                   //   REPORT_COUNT (8)
		0x91, 0x22,                   //   OUTPUT (Data,Var,Abs,NPrf)
		0x09, 0x00,                   //   USAGE (Undefined)
		0x15, 0x00,                   //   LOGICAL_MINIMUM (0)
		0x26, 0xff, 0x00,             //   LOGICAL_MAXIMUM (255)
		0x75, 0x08,                   //   REPORT_SIZE (8)
		0x95, 0x02,                   //   REPORT_COUNT (2)
		0x91, 0x22,                   //   OUTPUT (Data,Var,Abs,NPrf)

		0xc0,// END_COLLECTION

};

SI_SEGMENT_VARIABLE(deviceDesc[],
		const USB_DeviceDescriptor_TypeDef,
		SI_SEG_CODE) =
{
	USB_DEVICE_DESCSIZE,             // bLength
	USB_DEVICE_DESCRIPTOR,// bLength
	htole16(0x0200),// bcdUSB
	0xef,// bDeviceClass
	2,// bDeviceSubClass
	1,// bDeviceProtocol
	64,// bMaxPacketSize
	USB_VENDOR_ID,// idVendor
	USB_PRODUCT_ID,// idProduct
	htole16(0x0100),// bcdDevice
	1,// iManufacturer
	2,// iProduct
	3,// iSerialNumber
	1,// bNumConfigurations
};

SI_SEGMENT_VARIABLE(configDesc[],
		const uint8_t,
		SI_SEG_CODE) =
{
	USB_CONFIG_DESCSIZE,             // bLength
	USB_CONFIG_DESCRIPTOR,// bLength
	0x6b,// wTotalLength(LSB)
	0x00,// wTotalLength(MSB)
	3,// bNumInterfaces
	1,// bConfigurationValue
	0,// iConfiguration

	CONFIG_DESC_BM_RESERVED_D7,// bmAttrib: Bus powered

	CONFIG_DESC_MAXPOWER_mA(500),// bMaxPower: 500 mA

	// Interface Association Descriptor
	0x08, // bLength
	0x0b, // bDescriptorType
	0x00, // bFirstInterface
	0x02, // bInterfaceCount
	0x02, // bFunctionClass
	0x02, // bFunctionSubClass
	0x01, // bFunctionProtocol
	0x00, // iFunction

	//Interface 0 Descriptor
	USB_INTERFACE_DESCSIZE,// bLength
	USB_INTERFACE_DESCRIPTOR,// bDescriptorType
	0,// bInterfaceNumber
	0,// bAlternateSetting
	1,// bNumEndpoints
	2,// bInterfaceClass: Communications and CDC Control
	2,// bInterfaceSubClass
	2,// bInterfaceProtocol
	0,// iInterface

	// Header functional descriptor
	0x05, // bLength
	0x24, // bDescriptortype, CS_INTERFACE
	0x00, // bDescriptorsubtype, HEADER
	0x10, 0x01, // bcdCDC

	// ACM functional descriptor
	0x04, // bLength
	0x24, // bDescriptortype, CS_INTERFACE
	0x02, // bDescriptorsubtype, ABSTRACT CONTROL MANAGEMENT
	0x02, // bmCapabilities

	// Union functional descriptor
	0x05, // bLength
	0x24, // bDescriptortype, CS_INTERFACE
	0x06, // bDescriptorsubtype, UNION
	0x00, // bControlInterface
	0x01, // bSubordinateInterface0

	// Call Management functional
	0x05, // bLength
	0x24, // bDescriptortype, CS_INTERFACE
	0x01, // bDescriptorsubtype, CALL MANGEMENT
	0x03, // bCapabilities
	0x01, // bDataInterface

	//Endpoint 1 IN Descriptor
	USB_ENDPOINT_DESCSIZE,// bLength
	USB_ENDPOINT_DESCRIPTOR,// bDescriptorType
	0x81,// bEndpointAddress
	USB_EPTYPE_INTR,// bAttrib
	0x40,// wMaxPacketSize (LSB)
	0x00,// wMaxPacketSize (MSB)
	24,// bInterval

	//Interface 1 Descriptor
	USB_INTERFACE_DESCSIZE,// bLength
	USB_INTERFACE_DESCRIPTOR,// bDescriptorType
	1,// bInterfaceNumber
	0,// bAlternateSetting
	2,// bNumEndpoints
	10,// bInterfaceClass: CDC-Data
	0,// bInterfaceSubClass
	0,// bInterfaceProtocol
	0,// iInterface

	//Endpoint 2 IN Descriptor
	USB_ENDPOINT_DESCSIZE,// bLength
	USB_ENDPOINT_DESCRIPTOR,// bDescriptorType
	0x82,// bEndpointAddress
	USB_EPTYPE_BULK,// bAttrib
	0x40,// wMaxPacketSize (LSB)
	0x00,// wMaxPacketSize (MSB)
	24,// bInterval

	//Endpoint 2 OUT Descriptor
	USB_ENDPOINT_DESCSIZE,// bLength
	USB_ENDPOINT_DESCRIPTOR,// bDescriptorType
	0x02,// bEndpointAddress
	USB_EPTYPE_BULK,// bAttrib
	0x40,// wMaxPacketSize (LSB)
	0x00,// wMaxPacketSize (MSB)
	24,// bInterval

	//Interface 2 Descriptor
	USB_INTERFACE_DESCSIZE,// bLength
	USB_INTERFACE_DESCRIPTOR,// bDescriptorType
	2,// bInterfaceNumber
	0,// bAlternateSetting
	2,// bNumEndpoints
	3,// bInterfaceClass: HID (Human Interface Device)
	0,// bInterfaceSubClass
	0,// bInterfaceProtocol
	0,// iInterface

	//HID Descriptor
	USB_HID_DESCSIZE,// bLength
	USB_HID_DESCRIPTOR,// bLength
	0x11,// bcdHID (LSB)
	0x01,// bcdHID (MSB)
	0,// bCountryCode
	1,// bNumDescriptors
	USB_HID_REPORT_DESCRIPTOR,// bDescriptorType
	sizeof( ReportDescriptor2 ),// wDescriptorLength(LSB)
	sizeof( ReportDescriptor2 )>>8,// wDescriptorLength(MSB))

	//Endpoint 3 IN Descriptor
	USB_ENDPOINT_DESCSIZE,// bLength
	USB_ENDPOINT_DESCRIPTOR,// bDescriptorType
	0x83,// bEndpointAddress
	USB_EPTYPE_INTR,// bAttrib
	0x40,// wMaxPacketSize (LSB)
	0x00,// wMaxPacketSize (MSB)
	24,// bInterval

	//Endpoint 3 OUT Descriptor
	USB_ENDPOINT_DESCSIZE,// bLength
	USB_ENDPOINT_DESCRIPTOR,// bDescriptorType
	0x03,// bEndpointAddress
	USB_EPTYPE_INTR,// bAttrib
	0x40,// wMaxPacketSize (LSB)
	0x00,// wMaxPacketSize (MSB)
	24,// bInterval
};

#define LANG_STRING   htole16( SLAB_USB_LANGUAGE )
#define MFR_STRING                                'C','r','y','p','t','o',' ','a','n','d',' ','P','r','i','v','a','c','y',' ','V','i','l','l','a','g','e','\0'
#define MFR_SIZE                                  27
#define PROD_STRING                               'B','a','d','g','e',' ','2','0','1','7',' ','(','U','A','R','T','/','H','I','D','/','U','2','F',')','\0'
#define PROD_SIZE                                 26
#define SER_STRING                                '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','\0'
#define SER_SIZE                                  33

LANGID_STATIC_CONST_STRING_DESC( langDesc[], LANG_STRING );
UTF16LE_PACKED_STATIC_CONST_STRING_DESC( mfrDesc[], MFR_STRING, MFR_SIZE);
UTF16LE_PACKED_STATIC_CONST_STRING_DESC( prodDesc[], PROD_STRING, PROD_SIZE);
//UTF16LE_PACKED_STATIC_CONST_STRING_DESC( serDesc[], SER_STRING, SER_SIZE);
SI_SEGMENT_VARIABLE(serDesc[], USB_StringDescriptor_TypeDef, SI_SEG_XDATA) =
	{ USB_STRING_DESCRIPTOR_UTF16LE_PACKED, SER_SIZE * 2, USB_STRING_DESCRIPTOR, SER_STRING };

//-----------------------------------------------------------------------------
SI_SEGMENT_VARIABLE_SEGMENT_POINTER(myUsbStringTable_USEnglish[]
		, static const USB_StringDescriptor_TypeDef,
		SI_SEG_GENERIC,
		const SI_SEG_CODE) =
{
	(SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_CODE))langDesc,
	mfrDesc,
	prodDesc,
	serDesc,
};

//-----------------------------------------------------------------------------
SI_SEGMENT_VARIABLE(initstruct,
		const USBD_Init_TypeDef,
		SI_SEG_CODE) =
{
	(SI_VARIABLE_SEGMENT_POINTER(, USB_DeviceDescriptor_TypeDef, SI_SEG_GENERIC))deviceDesc, // deviceDescriptor
	(SI_VARIABLE_SEGMENT_POINTER(, USB_ConfigurationDescriptor_TypeDef, SI_SEG_GENERIC))configDesc,// configDescriptor
	(SI_VARIABLE_SEGMENT_POINTER(, USB_StringTable_TypeDef, SI_SEG_GENERIC))myUsbStringTable_USEnglish,// stringDescriptors
	sizeof(myUsbStringTable_USEnglish) / sizeof(myUsbStringTable_USEnglish[0])// numberOfStrings
};

#ifdef __cplusplus
}
#endif

