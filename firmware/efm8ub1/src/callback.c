/*******************************************************************************
 * @file callback.c
 * @brief USB Callbacks.
 *******************************************************************************/

//=============================================================================
// src/callback.c: generated by Hardware Configurator
//
// This file is only generated if it does not exist. Modifications in this file
// will persist even if Configurator generates code. To refresh this file,
// you must first delete it and then regenerate code.
//=============================================================================
//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <SI_EFM8UB1_Register_Enums.h>
#include <efm8_usb.h>
#include "descriptors.h"
#include "board.h"

//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

#define CDC_CONTROL_INTERFACE_INDEX 0
#define HID_INTERFACE_INDEX 2

//-----------------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------------

uint8_t tmpBuffer[8];

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------

void USBD_SofCb(uint16_t sofNr) {

}

void USBD_DeviceStateChangeCb(USBD_State_TypeDef oldState,
		USBD_State_TypeDef newState) {
	// If we're connected to a computer, virtually turn on
	if (newState == USBD_STATE_CONFIGURED) {
		//powerFlags |= POWER_FLAG_VIRTUAL_SWITCH_ON | POWER_FLAG_POWER_FLAGS_CHANGED;
	} else {
		powerFlags &= ~POWER_FLAG_VIRTUAL_SWITCH_ON;
		powerFlags |= POWER_FLAG_POWER_FLAGS_CHANGED;
	}
}

USB_Status_TypeDef USBD_SetupCmdCb(
		SI_VARIABLE_SEGMENT_POINTER(setup, USB_Setup_TypeDef, MEM_MODEL_SEG)) {
	USB_Status_TypeDef retVal = USB_STATUS_REQ_UNHANDLED;

	if ((setup->bmRequestType.Type == USB_SETUP_TYPE_STANDARD)
			&& (setup->bmRequestType.Direction == USB_SETUP_DIR_IN)
			&& (setup->bmRequestType.Recipient == USB_SETUP_RECIPIENT_INTERFACE)) {
		// A HID device must extend the standard GET_DESCRIPTOR command
		// with support for HID descriptors.

		switch (setup->bRequest) {
		case GET_DESCRIPTOR:
			if ((setup->wValue >> 8) == USB_HID_REPORT_DESCRIPTOR) {
				switch (setup->wIndex) {
				case 2: // Interface 2
					USBD_Write(EP0, ReportDescriptor2,
							   EFM8_MIN(sizeof(ReportDescriptor2), setup->wLength),
							   false);
					retVal = USB_STATUS_OK;
					break;
				}
			} else if ((setup->wValue >> 8) == USB_HID_DESCRIPTOR) {
				switch (setup->wIndex) {
				case 2: // Interface 2
					USBD_Write(EP0, (&configDesc[84]),
							EFM8_MIN(USB_HID_DESCSIZE, setup->wLength), false);
					retVal = USB_STATUS_OK;
					break;
				}
			}
			break;
		}
	} else if ((setup->bmRequestType.Type == USB_SETUP_TYPE_CLASS)
	           && (setup->bmRequestType.Recipient == USB_SETUP_RECIPIENT_INTERFACE)) {
		switch (setup->wIndex) {
		case CDC_CONTROL_INTERFACE_INDEX:
			switch (setup->bRequest)
			{
			case 0x20: // SET_LINE_CODING
				if (setup->bmRequestType.Direction == USB_SETUP_DIR_OUT && setup->wLength == 7)
				{
					// TODO: Actually change the UART
					USBD_Read(EP0, tmpBuffer, 7, false);
					uartBPS = *(uint32_t *)tmpBuffer;
					uartStopBits = tmpBuffer[4];
					uartParityType = tmpBuffer[5];
					uartDataBits = tmpBuffer[6];
					retVal = USB_STATUS_OK;
				} else {
					retVal = USB_STATUS_REQ_ERR;
				}
				break;
			case 0x21: // GET_LINE_CODING
				if (setup->bmRequestType.Direction == USB_SETUP_DIR_IN && setup->wLength == 7)
				{
					*(uint32_t *)tmpBuffer = uartBPS;
					tmpBuffer[4] = uartStopBits;
					tmpBuffer[5] = uartParityType;
					tmpBuffer[6] = uartDataBits;
					USBD_Write(EP0, tmpBuffer, 7, false);
					retVal = USB_STATUS_OK;
				} else {
					retVal = USB_STATUS_REQ_ERR;
				}
				break;
			case 0x22: // SET_CONTROL_LINE_STATE
				if (setup->bmRequestType.Direction == USB_SETUP_DIR_OUT)
				{
					// In an ideal world, we could rely on DTR and/or RTS to
					// control whether the UART is active. But we don't live
					// in that world.
					uartFlags = (setup->wValue & 3) | UART_FLAGS_UPDATED;
					retVal = USB_STATUS_OK;
				} else {
					retVal = USB_STATUS_REQ_ERR;
				}
				break;
			}
			break;
		case HID_INTERFACE_INDEX:
			// Implement the necessary HID class specific commands.
			switch (setup->bRequest)
			{
			case USB_HID_SET_IDLE:
				if (((setup->wValue & 0xFF) == 0)             // Report ID
						&& (setup->wLength == 0)
						&& (setup->bmRequestType.Direction != USB_SETUP_DIR_IN))
				{
					retVal = USB_STATUS_OK;
				}
				break;

			case USB_HID_GET_IDLE:
				if ((setup->wValue == 0)                      // Report ID
						&& (setup->wLength == 1)
						&& (setup->bmRequestType.Direction == USB_SETUP_DIR_IN))
				{
					tmpBuffer[0] = 24;
					USBD_Write(EP0, tmpBuffer, 1, false);
					retVal = USB_STATUS_OK;
				}
				break;
			}
			break;
		}
	}

	return retVal;
}

uint16_t USBD_XferCompleteCb(uint8_t epAddr, USB_Status_TypeDef status,
		uint16_t xferred, uint16_t remaining) {

	switch (epAddr) {
	case EP2OUT:
		if (fifo_getLength(&txFifo) == 0 && xferred) {
			/*
			// WHY IS THIS HERE? It's a long, sad story
			if (fifo_getFree(&txFifo) < xferred) {
				ledFrames[7].red = 0xff;
			}
			*/
			SBUF0 = *txBuf;
			fifo_putData(&txFifo, txBuf + 1, xferred - 1);
		} else {
			fifo_putData(&txFifo, txBuf, xferred);
		}
		lastUARTTxTime = _cur_ms;
		break;
	case EP3IN:
		// FIXME: This could be either report
		break;
	}
	return 0;
}

